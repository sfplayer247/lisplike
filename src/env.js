import parse from "./parseCode.js";
import execute from "./executeAST.js";

// import default modules
import operators from "./modules/operators.js";
import comparison from "./modules/comparison.js";
import misc from "./modules/misc.js";
import strings from "./modules/strings.js";
import plists from "./modules/plist.js";
import json from "./modules/json.js";
import requests from "./modules/requests.js";

export default class Environment {
  constructor() {
    this.parse = parse;
    this.execute = execute;
    this.output = "";
    this.options = {
      whileLoopProtection: true,
      maxWhileIterations: 10000
    };
    // Symbol Look Up Table
    this.symLUT = {};

    // Import all base modules into the lookup table
    this.importModule(misc);
    this.importModule(operators);
    this.importModule(comparison);
    this.importModule(strings);
    this.importModule(plists);
    this.importModule(json);
    this.importModule(requests);
  }

  // Used for importing javascript modules into the lookup table
  importModule(object) {
    this.symLUT = Object.assign(this.symLUT, object);
  }

  /*
  run(code:object)
  description: Runs code from an AST.

  param code
    type: object
    description: AST generated by the parser
  returns object
    desc: the enviroment the code ran in
  */
  run(code) {
    try {
      this.execute(this.parse(code), this);
      return this;
    } catch (e) {
      this.output += `[error][lle:${e.index}] ${e.value}\n`;
      return this;
    }
  }

  /*
  checkTypes(args:array, parameters:array)
  description: Checks if the args have the same types as in parameters.

  example
    checkTypes(args, ['string', 'integer'])
      This checks if args contains a string followed by an integer.

  param s
    type: string
    description: string to be converted to array
  returns object
    valid: whether the args are correct or not
    invalidType: what the type that was incorrectly matched was
    expected: the expected type
  */
  checkTypes(args, parameters) {
    for (let i = 0; i < args.length; i++) {
      if (args[i].type != parameters[i]) {
        return {
          valid: false,
          invalidType: args[i].type,
          expected: parameters[i]
        };
      }
    }
    return { valid: true };
  }

  /*
  error(number:int, message:string)
  description: Throws an error.

  param number
    type: int
    description: The number of the error, used for easy identification. Possible error numbers are in errorslist.txt.
  param message
    type: string
    description: The error message to throw.
  returns void
  */
  error(number, message) {
    throw {
      type: "error",
      value: {
        message: { type: "string", value: message },
        number: { type: "number", value: number }
      }
    };
  }
}
