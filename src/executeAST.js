// This function is a simple wrapper for runAST, documentation below
export default function execute(ast, env) {
  return runAST(ast, env);
}

/*
  runAST(token, env)
  description: Executes an Abstract Syntax Tree that was generated by the parser.

  param token
    type: object
    description: An atom from the AST
  param env
    type: object
    description: The enviroment in which the AST is supposed to run in.
  returns object
    description: The output of the AST provided.
*/
function runAST(token, env) {
  //
  // Expressions
  //
  if (token.type == "expression") {
    let args = [];
    //
    // Evaluate if statements
    //
    if (token.value[0].ref == "if") {
      // Run the condition and decide whether to run the code
      if (runAST(token.value[1], env).value == "true") {
        runAST(token.value[2], env);
      }
      // Check if there is an else statement
      else if (token.value.length == 4) {
        runAST(token.value[3], env);
      }
    }
    //
    // Evaluate function definitions
    //
    else if (token.value[0].ref == "func") {
      // Add the function into the lookup table
      env.symLUT[token.value[1].ref] = args => {
        env.symLUT.args = { type: "array", value: args };
        return runAST(token.value[2], env);
      };
    }
    //
    // Evaluate while loops
    //
    else if (token.value[0].ref == "while") {
      // Safehold put in place so you don't accidentally freeze the page
      let iterations = 0;
      while (
        runAST(token.value[1], env).value != "false" &&
        (iterations < env.options.maxWhileIterations ||
          !env.options.whileLoopProtection)
      ) {
        runAST(token.value[2], env);
        iterations++;
      }
      if (
        env.options.whileLoopProtection &&
        iterations >= env.options.maxWhileIterations
      ) {
        env.error(
          4,
          "While loop exceeded maximum amount of iterations. This can be disabled in the enviroment options."
        );
      }
    }
    //
    // Evaluate try statements
    //
    else if (token.value[0].ref == "try") {
      try {
        runAST(token.value[1], env);
      } catch (e) {
        env.symLUT.error = e;
        runAST(token.value[2], env);
      }
    }
    //
    // Evaluate normal expressions
    //
    else {
      for (let i = 1; i < token.value.length; i++) {
        args.push(runAST(token.value[i], env));
      }
      // If the first element is a function, run it with the arguments
      if (token.value[0].type == "symbol") {
        let result = runAST(token.value[0], env)(args, env);
        // Check if a property was accessed
        if (token.hasOwnProperty("property")) {
          return getProperty(result, token.property);
        } else {
          return result;
        }
      }
    }
  }
  //
  // Number
  //
  else if (token.type == "number") {
    return token;
  }
  //
  // Strings
  //
  else if (token.type == "string") {
    return token;
  }
  //
  // Booleans
  //
  else if (token.type == "boolean") {
    return token;
  }
  //
  // Symbols
  //
  else if (token.type == "symbol") {
    // Check if the symbol has a value in the lookup table
    if (token.ref in env.symLUT) {
      // Check if a property was accessed
      if (token.hasOwnProperty("property")) {
        return getProperty(env.symLUT[token.ref], token.property);
      } else {
        return env.symLUT[token.ref];
      }
    } else return token;
  }
  //
  // Property Lists
  //
  else if (token.type == "plist") {
    if (token.hasOwnProperty("property")) {
      return getProperty(token, token.property);
    } else {
      return token;
    }
  }
}

function getProperty(object, properties) {
  let out = object;
  for (let property of properties) {
    out = out.value[property];
  }
  return out;
}
